<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>QR Grid Scanner</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsQR Library for scanning -->
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <style>
        /* Prevent scrolling and bounce effects */
        body, html {
            overscroll-behavior: none;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }
    </style>
</head>
<body class="flex flex-col h-screen w-screen bg-gray-100 font-sans">

    <!-- TOP HALF: Visualization -->
    <div class="h-1/2 w-full bg-white relative flex items-center justify-center border-b-4 border-gray-300">
        
        <!-- Grid Container -->
        <div class="grid grid-cols-3 gap-4 p-4 aspect-square max-h-full">
            <!-- Grid Items generated by JS -->
            <div id="grid-container" class="contents">
                <!-- Dots will be injected here -->
            </div>
        </div>

        <!-- Reset Button (Bottom Right of Top Half) -->
        <button onclick="resetGrid()" class="absolute bottom-4 right-4 p-3 bg-gray-200 hover:bg-gray-300 rounded-full text-gray-700 transition shadow-sm z-10" aria-label="Reset">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="#000000" style="opacity:1;"><path  d="M6.03 2.47a.75.75 0 0 1 0 1.06L4.81 4.75H11A6.25 6.25 0 1 1 4.75 11a.75.75 0 0 1 1.5 0A4.75 4.75 0 1 0 11 6.25H4.81l1.22 1.22a.75.75 0 0 1-1.06 1.06l-2.5-2.5a.75.75 0 0 1 0-1.06l2.5-2.5a.75.75 0 0 1 1.06 0"/></svg>
        </button>
    </div>

    <!-- BOTTOM HALF: Camera -->
    <div class="h-1/2 w-full bg-black relative flex items-center justify-center overflow-hidden">
        
        <!-- Start Button -->
        <button id="start-btn" onclick="startCamera()" class="z-30 px-8 py-4 bg-blue-600 text-white font-bold text-xl rounded-lg shadow-lg active:scale-95 transition">
            Kamera starten
        </button>

        <!-- Video Element (Actual source, hidden visually but active) -->
        <video id="video" class="absolute inset-0 w-full h-full object-cover hidden" playsinline muted></video>
        
        <!-- Canvas for frame analysis AND visualization overlay -->
        <canvas id="canvas" class="absolute inset-0 w-full h-full object-cover hidden z-20"></canvas>
        
        <!-- Visual Overlay Guide -->
        <div id="scan-overlay" class="absolute inset-0 z-20 pointer-events-none flex items-center justify-center hidden">
            <!-- The hole in the middle with borders -->
            <div class="w-64 h-64 border-2 border-green-500/50 rounded-lg relative shadow-[0_0_0_9999px_rgba(0,0,0,0.6)]">
                <!-- Corner markers for style -->
                <div class="absolute top-0 left-0 w-4 h-4 border-t-4 border-l-4 border-green-500 -mt-1 -ml-1"></div>
                <div class="absolute top-0 right-0 w-4 h-4 border-t-4 border-r-4 border-green-500 -mt-1 -mr-1"></div>
                <div class="absolute bottom-0 left-0 w-4 h-4 border-b-4 border-l-4 border-green-500 -mb-1 -ml-1"></div>
                <div class="absolute bottom-0 right-0 w-4 h-4 border-b-4 border-r-4 border-green-500 -mb-1 -mr-1"></div>
            </div>
        </div>

        <!-- Debug / Feedback Overlay -->
        <div id="scan-feedback" class="absolute top-4 left-1/2 transform -translate-x-1/2 bg-black/60 text-white px-3 py-1 rounded-md text-xs font-mono hidden z-40 text-center max-w-[90%] break-words">
            Warten auf Kamera...
        </div>
    </div>

    <script>
        // State
        let processedDigits = [];
        let stream = null;
        
        // New Stability Logic State
        let pendingDigit = null;        // The digit currently being tracked
        let pendingDigitStartTime = 0;  // When this digit first became the pending candidate
        let lastSuccessfulScanTime = 0; // Timestamp of the last time we saw ANY valid digit

        // Constants
        const CONFIRMATION_TIME_MS = 1000; // 1 second to lock in
        const RESET_TIMEOUT_MS = 2000;     // 2 seconds of silence to reset pending state

        // Elements
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const canvasCtx = canvas.getContext("2d", { willReadFrequently: true });
        const startBtn = document.getElementById("start-btn");
        const gridContainer = document.getElementById("grid-container");
        const scanFeedback = document.getElementById("scan-feedback");
        const scanOverlay = document.getElementById("scan-overlay");

        // --- Grid Logic ---

        function renderGrid() {
            gridContainer.innerHTML = '';
            
            // Standard 3x3 Layout (1-9)
            for (let i = 1; i <= 9; i++) {
                const dot = document.createElement('div');
                
                // Base styles
                let className = "w-16 h-16 sm:w-20 sm:h-20 rounded-full flex items-center justify-center text-2xl font-bold text-white shadow-md transition-all duration-300";
                
                // Check if this digit (i) has been processed
                const orderIndex = processedDigits.indexOf(i);
                
                if (orderIndex !== -1) {
                    // It is processed: Green, show order number (1-based)
                    className += " bg-green-500 scale-105";
                    dot.textContent = orderIndex + 1;
                } else {
                    // Not processed: Red, empty
                    className += " bg-red-500";
                    dot.textContent = "";
                }

                dot.className = className;
                gridContainer.appendChild(dot);
            }
        }

        function processDigit(digit) {
            // If new, add to array
            if (!processedDigits.includes(digit)) {
                processedDigits.push(digit);
                renderGrid();
                
                // Visual feedback that a scan happened
                pulseFeedback("Bestätigt: " + digit);
            } else {
                 // Even if already processed, show feedback so user knows it was seen
                 if (!scanFeedback.classList.contains("bg-green-600")) {
                     scanFeedback.textContent = "Bereits gescannt: " + digit;
                 }
            }
        }

        function resetGrid() {
            processedDigits = [];
            pendingDigit = null;
            pendingDigitStartTime = 0;
            renderGrid();
            
            scanFeedback.textContent = "Scanne...";
            scanFeedback.classList.remove("bg-green-600");
            scanFeedback.classList.add("bg-black/60");
        }

        function pulseFeedback(msg) {
            scanFeedback.textContent = msg;
            scanFeedback.classList.remove("bg-black/60");
            scanFeedback.classList.add("bg-green-600");
            setTimeout(() => {
                scanFeedback.textContent = "Scanne...";
                scanFeedback.classList.remove("bg-green-600");
                scanFeedback.classList.add("bg-black/60");
            }, 1000);
        }

        // --- Camera & Scanning Logic ---

        async function startCamera() {
            startBtn.textContent = "Laden...";
            startBtn.disabled = true;

            try {
                // Request camera with preference for back camera
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: "environment",
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                });
                
                video.srcObject = stream;
                video.setAttribute("playsinline", true); 
                
                // Play immediately to avoid double-click issues
                await video.play();

                // Setup UI once playing
                startBtn.classList.add("hidden");
                canvas.classList.remove("hidden");
                scanFeedback.classList.remove("hidden");
                scanOverlay.classList.remove("hidden");
                scanFeedback.textContent = "Kamera gestartet. Scanne...";
                
                requestAnimationFrame(tick);

            } catch (err) {
                console.error("Error accessing camera", err);
                alert("Zugriff auf Kamera nicht möglich. Bitte Berechtigungen prüfen und HTTPS verwenden.");
                startBtn.disabled = false;
                startBtn.textContent = "Kamera erneut versuchen";
            }
        }

        function drawLine(begin, end, color) {
            canvasCtx.beginPath();
            canvasCtx.moveTo(begin.x, begin.y);
            canvasCtx.lineTo(end.x, end.y);
            canvasCtx.lineWidth = 4;
            canvasCtx.strokeStyle = color;
            canvasCtx.stroke();
        }

        function tick() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // Sync canvas size to video size
                if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                }
                
                // 1. Draw full video to canvas
                canvasCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // 2. Define Scan Region (Center ~60%)
                const minDim = Math.min(canvas.width, canvas.height);
                const scanSize = Math.floor(minDim * 0.6); 
                const scanX = Math.floor((canvas.width - scanSize) / 2);
                const scanY = Math.floor((canvas.height - scanSize) / 2);

                // 3. Extract only the center image data for scanning
                const imageData = canvasCtx.getImageData(scanX, scanY, scanSize, scanSize);
                
                // 4. Scan the cropped data
                const code = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: "attemptBoth",
                });

                const now = Date.now();
                let foundValidDigit = false;

                if (code) {
                    // Helper to adjust cropped coordinates back to full canvas coordinates for drawing
                    const adjust = (pt) => ({ x: pt.x + scanX, y: pt.y + scanY });

                    // Draw Box
                    const color = "#FF3B58";
                    drawLine(adjust(code.location.topLeftCorner), adjust(code.location.topRightCorner), color);
                    drawLine(adjust(code.location.topRightCorner), adjust(code.location.bottomRightCorner), color);
                    drawLine(adjust(code.location.bottomRightCorner), adjust(code.location.bottomLeftCorner), color);
                    drawLine(adjust(code.location.bottomLeftCorner), adjust(code.location.topLeftCorner), color);

                    // Parse Text
                    const match = code.data.match(/n=(\d)/);
                    
                    if (match && match[1]) {
                        const detectedDigit = parseInt(match[1]);
                        foundValidDigit = true;
                        lastSuccessfulScanTime = now;

                        // Stability Logic
                        if (detectedDigit !== pendingDigit) {
                            // New or different digit: Reset timer
                            pendingDigit = detectedDigit;
                            pendingDigitStartTime = now;
                            if (!scanFeedback.classList.contains("bg-green-600")) {
                                scanFeedback.textContent = `Gefunden: ${detectedDigit} (Verifizieren...)`;
                            }
                        } else {
                            // Same digit as pending
                            const elapsed = now - pendingDigitStartTime;
                            
                            // Visual feedback
                            if (elapsed < CONFIRMATION_TIME_MS) {
                                if (!scanFeedback.classList.contains("bg-green-600")) {
                                    scanFeedback.textContent = `Gefunden: ${detectedDigit} (${(elapsed/1000).toFixed(1)}s)`;
                                }
                            } else {
                                // Time met!
                                processDigit(detectedDigit);
                            }
                        }
                    } else {
                         // Found a QR, but not the right pattern
                         if (!scanFeedback.classList.contains("bg-green-600")) {
                             scanFeedback.textContent = "QR gefunden (keine Ziffer)";
                         }
                    }
                }

                // Reset Logic: If no valid digit seen for > 2 seconds
                if (!foundValidDigit) {
                    if (now - lastSuccessfulScanTime > RESET_TIMEOUT_MS) {
                        pendingDigit = null;
                        pendingDigitStartTime = 0;
                        if (!scanFeedback.classList.contains("bg-green-600")) {
                            scanFeedback.textContent = "Scanne...";
                        }
                    }
                }
            }
            requestAnimationFrame(tick);
        }

        // Initialize
        renderGrid();

    </script>
</body>
</html>